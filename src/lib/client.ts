import { KadenceAttribute, KadenceEntity, KadenceEntityRef, KadenceRelation, KadenceTable, LoggingLevel } from "../types/object";
import { StringTypes } from "../types/source";
import { executeQuery } from "./util";
import { global } from "../types/global";

export class KadenceSingularQuery<T extends KadenceEntity> {
    tableDef?: KadenceTable;
    object: T;

    constructor(c: T) {
        // Set the object variable for reference in the insert and update methods
        this.object = c;
        
        // Get the table definition from the global object
        const k = global.dataObjects as KadenceEntityRef;

        this.tableDef = k[c.constructor.name] as KadenceTable;
    }

    async insert(): Promise<T> {
        if (!this.tableDef) {
            throw new Error('Entity definition not found');
        }
        else if (!this.tableDef.source) {
            throw new Error('Entity data source not defined');
        }
        else {
            let query = `INSERT INTO ${this.tableDef?.tableName} (`;

            this.tableDef.attributes.forEach((attribute) => {
                if (!attribute.autoGenerated) {
                    query += `${attribute.fieldName}, `;
                }
            });

            query = query.slice(0, -2);
            query += ') VALUES (';

            this.tableDef.attributes.forEach((attribute) => {
                if (!attribute.autoGenerated) {
                    query += `'${this.object[attribute.name as keyof T]}', `;
                }
            });

            query = query.slice(0, -2);
            query += `) RETURNING ${getDefinedFields(this.tableDef).join(", ")}`;
            
            return await executeQuery(this.tableDef.source, query, this.tableDef.loggingLevel ? this.tableDef.loggingLevel : LoggingLevel.None)
                .then(async (result: any) => {
                    const final = await mapSingleObject(this.tableDef!, this.object, result);
                    return final as T;
                })
                .catch((error: any) => {
                    throw new Error(error);
                });
        }
    }

    async update(): Promise<T> {
        if (!this.tableDef) {
            throw new Error('Entity definition not found');
        }
        else if (!this.tableDef.source) {
            throw new Error('Entity data source not defined');
        }
        else if (!this.tableDef?.uniqueIds) {
            throw new Error('Unique identifier not defined');
        }
        else {
            let query = `UPDATE ${this.tableDef?.tableName} SET `;

            this.tableDef.attributes.forEach((attribute) => {
                if (!attribute.autoGenerated) {
                    query += `${attribute.fieldName} = '${this.object[attribute.name as keyof T]}', `;
                }
            });

            query = query.slice(0, -2);

            if (this.tableDef.uniqueIds) {
                query += ' WHERE ';

                this.tableDef.uniqueIds.forEach(async (id: string) => {
                    await this.tableDef?.attributes.map((attribute) => {
                        if (attribute.name === id && (<any>Object).values(StringTypes).includes(attribute.dataType)) {
                            query += `${id} = '${this.object[id as keyof T]}' AND `;
                        }
                        else if (attribute.name === id) {
                            query += `${id} = ${this.object[id as keyof T]} AND `;
                        }
                    });
                });

                query = query.slice(0, -5);
            }

            query += ` RETURNING ${getDefinedFields(this.tableDef).join(", ")}`;
            
            return await executeQuery(this.tableDef.source, query, this.tableDef.loggingLevel ? this.tableDef.loggingLevel : LoggingLevel.None)
                .then(async (result: any) => {
                    const final = await mapSingleObject(this.tableDef!, this.object, result);
                    return final as T;
                })
                .catch((error: any) => {
                    throw new Error(error);
                });
        }
    }

    async delete(): Promise<boolean> {
        if (!this.tableDef) {
            throw new Error('Entity definition not found');
        }
        else if (!this.tableDef.source) {
            throw new Error('Entity data source not defined');
        }
        else if (!this.tableDef?.uniqueIds) {
            throw new Error('Unique identifier not defined');
        }
        else {
            let query = `DELETE FROM ${this.tableDef?.tableName} WHERE `;

            this.tableDef.uniqueIds.forEach(async (id: string) => {
                await this.tableDef?.attributes.map((attribute) => {
                    if (attribute.name === id && (<any>Object).values(StringTypes).includes(attribute.dataType)) {
                        query += `${id} = '${this.object[id as keyof T]}' AND `;
                    }
                    else if (attribute.name === id) {
                        query += `${id} = ${this.object[id as keyof T]} AND `;
                    }
                });
            });
            
            query = query.slice(0, -5);
            
            return await executeQuery(this.tableDef.source, query, this.tableDef.loggingLevel ? this.tableDef.loggingLevel : LoggingLevel.None)
            .then((result: any) => {
                return true;
            })
            .catch((error: any) => {
                throw new Error(error);
            });
        }
    }
}

export class KadenceQuery<T extends KadenceEntity> {
    private newObject: new() => T;
    tableDef?: KadenceTable;
    parent?: KadenceQuery<T>;
    attributes: string[] = [];
    parameters: any[] = [];
    values: any[] = [];
    filter: Filter[] = [];
    orFilter: Filter[] = [];
    sort: Sort[] = [];
    limit?: number;
    relations: Relationship<T>[] = [];
    operation?: DataOperation;

    constructor(c: new() => T) {
        // Initialize the class to ensure the decorators are executed and the table is created in global.dataObjects
        const initializeClass = new c();

        // Set the newObject variable for reference in the select method to ensure typing works properly
        this.newObject = c;

        // Get the table definition from the global object
        const k = global.dataObjects as KadenceEntityRef;

        this.tableDef = k[this.newObject.name];

        // Set default attributes based on defined fields
        this.attributes = getDefinedFields(k[this.newObject.name]);
    }

    addAttributes(attributes: string[]) {
        this.attributes = [];
        
        // Set attributes to the underlying field names
        attributes.forEach((attribute) => {
            this.attributes.push(this.getFieldName(attribute));
        });

        // Always include unique ids to ensure we can perform later updates or deletes
        this.tableDef?.uniqueIds.forEach((id) => {
            this.attributes.find((attr) => attr === id) ? null : this.attributes.push(id);
        });

        return this;
    }

    setValue(field: string, value: any) {
        this.parameters.push({ field: this.getFieldName(field), value: value });

        return this;
    }

    addFilter(field: string, operator: FilterOperator, value: any) {
        // keyof typeof this.attributes
        const newOperator = operator as FilterOperator;
        const filter = new Filter(FilterType.And, this.getFieldName(field as string), newOperator, value);
        
        this.filter.push(filter);
        
        return this;
    }

    addExactFilter(field: string, value: any) {
        const filter = new Filter(FilterType.And, this.getFieldName(field), "=", value);
        
        this.filter.push(filter);
        
        return this;
    }

    addOrFilter(field: string, operator: FilterOperator, value: any) {
        const newOperator = operator as FilterOperator;
        const filter = new Filter(FilterType.Or, this.getFieldName(field), newOperator, value);
        
        this.filter.push(filter);
        
        return this;
    }

    addExactOrFilter(field: string, value: any) {
        const filter = new Filter(FilterType.Or, this.getFieldName(field), "=", value);
        
        this.filter.push(filter);
        
        return this;
    }

    addSort<T>(field: string, direction?: SortDirection | null) {
        let newDirection = null;

        if (direction) newDirection = direction as SortDirection;

        const newSort = new Sort(this.getFieldName(field!.toString()), newDirection || "ASC");
        this.sort.push(newSort);
        
        return this;
    }

    addLimit(limit: number) {
        this.limit = limit;
        return this;
    }

    addRelation<R extends KadenceEntity>(c: new() => R, withFilter?: boolean): KadenceQuery<T> {
        // TODO: Add Loading Strategy to paramters: loadingStrategy: RelationLoadStrategy
        const client = this.addFilteredRelation(c, withFilter);

        return this;
    }

    addFilteredRelation<R extends KadenceEntity>(c: new() => R, withFilter?: boolean): KadenceQuery<R> {
        // TODO: Add Loading Strategy to paramters: loadingStrategy: RelationLoadStrategy
        const client = new KadenceQuery(c);
        let hasRelation = false;

        // If withFilter is not defined, default to false
        if (withFilter == undefined) withFilter = false;

        // Find the matching relation in the table definition
        this.tableDef?.relations.forEach((rel) => {
            if (rel.table === c.name) {
                /*if (loadingStrategy === "eager" && relation.object?.source.provider !== this.source!.provider) {
                    throw new Error("Relationships cannot be eagerly loaded from different data sources");
                }
                else {*/
                    // @ts-ignore
                    client.parent = this;

                    this.relations.push({
                        strategy: "lazy",
                        relation: rel,
                        // @ts-ignore
                        client: client,
                    });

                    hasRelation = true;
                //}
            }
        });

        // Throw an error if the relation is not found
        if (!hasRelation) 
            throw new Error("Relation not found");

        return client;
    }

    endFilteredRelation(): KadenceQuery<T> {
        // Return the parent query object if it's defined
        if (this.parent) {
            return this.parent;
        }
        // Otherwise, return the current query object
        else {
            return this;
        }
    }

    private getFieldName(field: string) {
        const attribute = this.tableDef?.attributes.find((attr) => attr.name === field);

        if (field && attribute) {
            return attribute.fieldName;
        }
        else {
            return field;
        }
    }

    async select(): Promise<T[]> {
        this.operation = DataOperation.Read;
        
        let result = await executeQuery(this.tableDef?.source!, this.getSQLQuery(), this.tableDef?.loggingLevel ? this.tableDef.loggingLevel : LoggingLevel.None);

        if (result && this.relations.length > 0) {
            await Promise.all(result.map(async (record: any, index) => {
                await Promise.all(this.relations.map(async (relation: Relationship<T>) => {
                    const filter: Filter = {
                        type: FilterType.And,
                        field: relation.relation.targetField,
                        operator: "=",
                        value: record[relation.relation.sourceField],
                    };
                    
                    relation.client.filter = [ filter ];
                    const clientResult = await relation.client.select();

                    // @ts-ignore
                    result[index][relation.relation.fieldName] = clientResult;
                }));
            }));
        }
        
        this.clearQuery();

        return await mapObjects<T>(this.tableDef!, this.newObject, result);
    }

    /*insert() {
        this.operation = DataOperation.Create;
        
        executeQuery(this.tableDef?.source!, this.getSQLQuery());
    }*/

    async update(): Promise<T[]> {
        this.operation = DataOperation.Update;
        
        const result = await executeQuery(this.tableDef?.source!, this.getSQLQuery(), this.tableDef?.loggingLevel ? this.tableDef.loggingLevel : LoggingLevel.None);

        this.clearQuery();

        return await mapObjects<T>(this.tableDef!, this.newObject, result);
    }

    async delete(): Promise<boolean> {
        this.operation = DataOperation.Delete;
        
        await executeQuery(this.tableDef?.source!, this.getSQLQuery(), this.tableDef?.loggingLevel ? this.tableDef.loggingLevel : LoggingLevel.None)
        .then((result: any) => {
            return true;
        })
        .catch((error: any) => {
            throw new Error(error);
        });

        this.clearQuery();

        return true;
    }

    private clearQuery() {
        // Set default attributes based on defined fields
        this.attributes = getDefinedFields(this.tableDef!);

        // Clear all other attributes
        this.parent = undefined;
        this.parameters = [];
        this.values = [];
        this.filter = [];
        this.orFilter = [];
        this.sort = [];
        this.limit = undefined;
        this.relations = [];
        this.operation = undefined;
    }

    getSQLQuery() {
        let query = "";
        
        switch (this.operation) {
            case DataOperation.Read:
                query = `SELECT ${this.attributes.length > 0 ? this.attributes!.join(", ") : "*"} FROM ${this.tableDef?.tableName}`;
                
                if (this.filter.length > 0 || this.orFilter.length > 0) {
                    query += this.getWhereClause();
                }

                if (this.sort!.length > 0) {
                    query += " ORDER BY";

                    this.sort.map(async (sort: Sort, index: number) => {
                        query += ` ${sort.field} ${sort.direction}`;
                        
                        if (index < this.sort!.length - 1) {
                            query += ",";
                        }
                    });
                }
                
                if (this.limit) {
                    query += ` LIMIT ${this.limit}`;
                }
                
                break;
            case DataOperation.Create:
                let fields: string[] = [];
                let values: string[] = [];

                this.parameters.forEach((param) => {
                    fields.push(this.getFieldName(param.field));
                    values.push(param.value);
                });

                query = `INSERT INTO ${this.tableDef?.tableName} (${fields!.join(", ")}) VALUES (${values!.join(", ")})`;
                
                break;
            case DataOperation.Update:
                query = `UPDATE ${this.tableDef?.tableName} SET`;

                this.parameters?.forEach((parameter: any, index: number) => {
                    const attrType = this.tableDef?.attributes.find((attr) => attr.name === parameter.field)?.dataType;

                    if ((<any>Object).values(StringTypes).includes(attrType)) {
                        query += ` ${parameter.field} = '${parameter.value}', `;
                    }
                    else {
                        query += ` ${parameter.field} = ${parameter.value}, `;
                    }
                });

                query = query.slice(0, -2);
                query += this.getWhereClause();
                query += ` RETURNING ${this.attributes.join(", ")}`;
                
                break;
            case DataOperation.Delete:
                query = `DELETE FROM ${this.tableDef?.tableName}`

                if (this.filter.length > 0 || this.orFilter.length > 0) {
                    query += this.getWhereClause();
                }

                break;
        }

        return query;
    }
    
    protected getWhereClause() {
        let query = " WHERE";

        const combinedFilter = this.filter.concat(this.orFilter);

        combinedFilter?.forEach((filter: Filter, index: number) => {
            let type = index === 0 ? "" : ` ${filter.type.toString()}`;

            if (filter.value === true || filter.value === false || typeof filter.value === "number") {
                query += `${type} ${filter.field} ${filter.operator} ${filter.value}`;
            }
            else {
                if (filter.operator === "STARTS WITH") {
                    query += `${type} ${filter.field} LIKE '${filter.value}%'`;

                }
                else if (filter.operator === "ENDS WITH") {
                    query += `${type} ${filter.field} LIKE '%${filter.value}'`;
                }
                else if (filter.operator === "LIKE" || filter.operator === "NOT LIKE") {
                    query += `${type} ${filter.field} ${filter.operator} '%${filter.value}%'`;
                }
                else {
                    query += `${type} ${filter.field} ${filter.operator} '${filter.value}'`;
                }
            }
        });

        return query;
    }
}

/*async function validateObject<T extends KadenceObject>(tableDef: KadenceTable, object: T): Promise<boolean> {
    return false;
}*/

function getDefinedFields(tableDef: KadenceTable) {
    let fields: string[] = [];

    if (!tableDef) {
        throw new Error('Entity definition not found');
    }
    
    tableDef.attributes.forEach((attribute) => {
        fields.push(attribute.fieldName);
    });

    return fields;
}

async function mapSingleObject<T extends KadenceEntity>(tableDef: KadenceTable, result: T, object: any[] | null): Promise<T> {
    let newObject: T[] = [];
    let fieldNames: Record<string, string>[] = [];

    await Object.keys(tableDef.attributes).map((attribute: any) => {
        const name = tableDef.attributes[attribute].name;
        const fieldName = tableDef.attributes[attribute].fieldName;

        fieldNames.push({
            objectName: name != undefined ? name : attribute,
            sourceName: fieldName != undefined ? fieldName : name != undefined ? name : attribute,
        });
    });

    await object?.map(async (item, index) => {
        let newObj = result;

        Object.entries(item).map(([key, value]) => {
            let field = fieldNames.find((field) => field.sourceName === key);
            
            if (field !== undefined && key !== field.objectName) {
                newObj[field.objectName as keyof T] = object[index][field.sourceName];
                
                object[index][field.objectName] = object[index][field.sourceName];
                delete object[index][key];
            }
            else if (field === undefined) {
                delete object[index][key];
            }
        });

        newObject.push(newObj);
    });

    return newObject[0];
}

async function mapObjects<T extends KadenceEntity>(tableDef: KadenceTable, c: new () => T, object: any[] | null): Promise<T[]> {
    let newObject: T[] = [];
    let fieldNames: Record<string, string>[] = [];

    await Object.keys(tableDef.attributes).map((attribute: any) => {
        const name = tableDef.attributes[attribute].name;
        const fieldName = tableDef.attributes[attribute].fieldName;

        fieldNames.push({
            objectName: name != undefined ? name : attribute,
            sourceName: fieldName != undefined ? fieldName : name != undefined ? name : attribute,
        });
    });

    await Object.keys(tableDef.relations).map((relation: any) => {
        const name = tableDef.relations[relation].fieldName;

        fieldNames.push({
            objectName: name != undefined ? name : relation,
            sourceName: name != undefined ? name : relation,
        });
    });

    await object?.map(async (item, index) => {
        let newObj = new c();
        //newObj.setDefinition(tableDef);

        Object.entries(item).map(([key, value]) => {
            let field = fieldNames.find((field) => field.sourceName === key);

            if (field != undefined) {
                newObj[field.objectName as keyof T] = object[index][field.sourceName];
            }
        });

        newObject.push(newObj);
    });

    return newObject;
}

type Relationship<R extends KadenceEntity> = {
    strategy: RelationLoadStrategy;
    relation: KadenceRelation;
    client: KadenceQuery<R>;
}

export enum DataOperation {
    Create = "create",
    Read = "read",
    Update = "update",
    Delete = "delete",
}

export enum FilterType {
    And = "AND",
    Or = "OR",
}

type FilterOperator = "=" | "!=" | ">" | ">=" | "<" | "<=" | "LIKE" | "NOT LIKE" | "STARTS WITH" | "ENDS WITH" | "IN" | "NOT IN" | "BETWEEN" | "NOT BETWEEN" | "IS NULL" | "IS NOT NULL";

class Filter {
    type: FilterType;
    field: string;
    operator: FilterOperator;
    value: any;

    constructor(type: FilterType, field: string, operator: FilterOperator, value: any) {
        this.type = type;
        this.field = field;
        this.operator = operator;
        this.value = value;
    }
}

type RelationLoadStrategy = "lazy" | "eager";

type SortDirection = "ASC" | "DESC";

class Sort {
    field: string;
    direction: SortDirection;

    constructor(field: string, direction: SortDirection) {
        this.field = field;
        this.direction = direction;
    }
}