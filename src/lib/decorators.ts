import "reflect-metadata";
import { KadenceDataSource } from "../types/source";
import { KadenceEntity, KadenceEntityRef, KadenceTable, LoggingLevel } from "../types/object";
import { global } from "../types/global";

export function Entity(options: { source: KadenceDataSource, tableName: string, uniqueIds: string[], loggingLevel?: LoggingLevel }) {
    return function (target: any) {
        const obj = new (target as any);
console.log('Entity decorator');
        if (!options.loggingLevel) options.loggingLevel = LoggingLevel.None;

        const newObject: KadenceTable = new KadenceTable(obj.constructor.name);
        newObject.source = options.source;
        newObject.tableName = options.tableName;

        if (global.dataObjects) {
            let hasObject = false;

            Object.keys(global.dataObjects).forEach((obj) => {
                if (obj == newObject.name) {
                    (global.dataObjects as KadenceEntityRef)[obj].source = newObject.source;
                    (global.dataObjects as KadenceEntityRef)[obj].tableName = newObject.tableName;
                    (global.dataObjects as KadenceEntityRef)[obj].uniqueIds = options.uniqueIds;
                    (global.dataObjects as KadenceEntityRef)[obj].loggingLevel = options.loggingLevel;

                    hasObject = true;
                }
            });

            if (!hasObject) (global.dataObjects as KadenceEntityRef)[newObject.name] = newObject;
        }
        else {
            const ref = new KadenceEntityRef();

            ref[newObject.name] = newObject;
            
            global.dataObjects = ref;
        }
    }
}

export function Attribute(options? : { fieldName?: string, type?: string }) {
    return function (target: any, key: any) {
        console.log('Attribute decorator');
        const attribute = {
            name: key,
            fieldName: options?.fieldName || key,
            objectType: Reflect.getMetadata("design:type", target, key).name.toLowerCase(),
            dataType: options?.type || Reflect.getMetadata("design:type", target, key).name.toLowerCase(),
            autoGenerated: options?.type == "uuid" ? true : false
        };

        if ((global as any).dataObjects) {
            let hasObject = false;

            Object.keys((global as any).dataObjects).forEach((obj) => {
                if (obj == target.constructor.name) {
                    (global as any).dataObjects[obj].attributes.push(attribute);

                    hasObject = true;
                }
            });

            if (!hasObject) {
                (global.dataObjects as KadenceEntityRef)[target.constructor.name] = new KadenceTable(target.constructor.name, [attribute]);
            }
        }
        else {
            const ref = new KadenceEntityRef();

            const newTable = new KadenceTable(target.constructor.name);
            newTable.attributes = [attribute];

            ref[target.constructor.name] = newTable;
            
            global.dataObjects = ref;
        }
    }
}

export function Relation(options : { class: any, sourceField: string, targetField: string }) {
    return function (target: any, key: any) {
        const obj = new (options.class as any);
       
        const newRelation = {
            fieldName: key,
            table: obj.constructor.name,
            class: options.class,
            sourceField: options.sourceField,
            targetField: options.targetField
        };

        if (global.dataObjects) {
            (global.dataObjects as KadenceEntityRef)[target.constructor.name].relations.push(newRelation);
        }
        else {
            const ref = new KadenceEntityRef();

            const newTable = new KadenceTable(target.constructor.name);
            newTable.relations = [newRelation];

            ref[target.constructor.name] = newTable;
            
            global.dataObjects = ref;
        }
    }
}